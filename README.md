## Структуры данных
### DSU
Будем хранить систему как лес. Одно множество - дерево. У каждого множества есть representative - корень этого дерева. Для хранения леся используем массив parent. parentOfA = parent[A]. Все элементы которые хранятся в этой системе множеств занумерованы [0, n). Если елемент - корень дерева то в массиве parent храним особое значение (обычно делают parent[A] = A).

**Основные операции:**

1. **findRepresentative(x)** x - какой то произвольный элемент системы, representative которого мы хотим найти. Ищем рекурсивно representative у парента x пока не наткнемся на корень. Для поддержания асимптотики делаем компрессию путей (все вершины которые мы встретим на пути к representative, на анроллинге рекурсии будем подвешивать напрямую к representative)

2. **unite(x, y)** — объединение двух множеств элементами которых являются x и y. Находим representative обоих и хотим подвесить одного к другому. Для поддержания асимптотики будем хранить rank деревьев(можно глубину, либо количество нод) и будем подвешивать меньшее дерево к бОльшему. При подвеске обновляем новые размеры деревьев

3. **connected(x, y)** => **findRepresentative(x)** == **findRepresentative(y)** — проверка принадлежности одному множеству 

**Расширенные возможности:**

1. Можно хранить доп инфу о множествах по аналогии с тем как мы храним rank для оптимизации **unite()**

2. Rollback

**DSU с откатом (Rollback DSU):**
```cpp
class RollbackDSU {
    vector<int> parent, rank;
    stack<pair<int, int>> history;  // (index, old_parent)
    
public:
    RollbackDSU(int n) : parent(n), rank(n, 0) {
        iota(parent.begin(), parent.end(), 0);
    }
    
    int find(int x) {
        while (parent[x] != x) x = parent[x];
        return x;
    }
    
    bool unite(int x, int y) {
        x = find(x); y = find(y);
        if (x == y) return false;
        if (rank[x] < rank[y]) swap(x, y);
        history.push({y, parent[y]});
        history.push({x, rank[x]});
        parent[y] = x;
        if (rank[x] == rank[y]) rank[x]++;
        return true;
    }
    
    void rollback() {
        if (history.empty()) return;
        int x = history.top().first;
        rank[x] = history.top().second;
        history.pop();
        int y = history.top().first;
        parent[y] = history.top().second;
        history.pop();
    }
};
```

**Применения:**
- Алгоритм Краскала (минимальное остовное дерево)
- Проверка связности графа
- Поиск компонент связности
- Offline запросы на добавление рёбер
- LCA (Lowest Common Ancestor) через offline запросы
```
bool visited[n]  

function union(x : int, y : int, newAncestor : int):
    leader = dsuUnion(x, y)         // объединяем классы вершин x
 и y
 и получаем нового представителя класса 
    lcaClass[leader] = newAncestor  // устанавливаем нового предка представителю множества 
      
// можно запустить от любой вершины дерева в самый первый раз  
function dfs(v : int):
    visited[v] = true
    lcaClass[v] = v                     
    foreach u : (v, u) in G
        if not visited[u]                  
            dfs(u)
            union(v, u, v)
    for (u : ⟨v,u⟩
 — есть такой запрос)
        if visited[u]
            запомнить, что ответ для запроса ⟨v,u⟩
 = lcaClass[find[u]]
 ```


- Динамическая связность (с откатами)
- Painting subarrays

### Дерево отрезков (Segment Tree)
### Дерево Фенвика (Fenwick Tree / Binary Indexed Tree)
### Корневая декомпозиция (Square Root Decomposition)
### Куча (Heap), приоритетная очередь
### Декартово дерево (Treap)

## Графы
### Алгоритм Дейкстры (кратчайшие пути)
Когда граф представляется n слоями между которыми есть соединения все со всеми (как в нейросети) то имеет смысл писать ДП вместо дейкстры (не обязательно чтобы были соединения все со всеми но важно чтобы не было соединений между нодами в слое либо между нодами в несоседних слоях). Дп двумерная dp[номер слоя][вершины на слое]. В дп храним длину кратчайшего пути до вершины в слое. Пересчет: dp[i][j] = min_k(dp[i - 1][k] + длина ребра из [i - 1][k] в [i][j]). Такая дпшка легко пересчитывается по слоям пямять O(n - максимум елементов в слое). Время O(n*(m^2)) n - количество слоёв, m - максимум элементов в слое.


### Алгоритм Флойда-Уоршелла
### Алгоритм Беллмана-Форда
### Минимальное остовное дерево (Прим, Краскал)
### Топологическая сортировка
### Мосты и точки сочленения
### Lowest Common Ancestor (LCA)
Наименьший общий предок. Дано дерево, хотим отвечать на запросы вида (u, v), хотим находить наименьшего общего предка. (Через этого чувака проходит кратчайший путь из u в v)

#### Можно реализовать на DSU если offline запросы (см DSU)

#### Можно реализовать на RMQ например с помощью ДО.
Запустим DFS по дереву. Во время обхода будем записывать массив из пар (посещенная вершина, глубина в дереве обхода). Длина такого массива O(n) т.к во время обхода по каждому ребру мы проходим дважды (заходим и выходим) а ребер в дереве (n - 1) от количества вершин.

Насчитаем также индекс первого вхождения ноды в наш массив.

Теперь заметим следующее, LCA(u, v) = вершине с минимальной высотой между первым вхождением в обходе u и первым вхождением в обходе v. Интуитивно это так потому что DFS выходит наверх только когда уже посетил все дочерние ноды.

Таким образом задача сведена к поиску минимума на отрезке.

### Компоненты сильной связности (Косарайю, Тарьян)
### 2-SAT
### Паросочетания (matching)
### Максимальный поток (max flow)
### Минимальная стоимость потока
### Эйлеров путь и цикл
### Гамильтонов путь (динамика по подмножествам)

## Динамическое программирование (ДП/DP)
### Рюкзак (Knapsack)
### Longest Increasing Subsequence (LIS)
### Longest Common Subsequence (LCS)
### Расстояние по Ливенштейну
### ДП на деревьях
### ДП по подмножествам (Bitmask DP)
### ДП с оптимизацией выпуклой оболочкой (Convex Hull Trick)
### Divide and Conquer Optimization
### Knuth Optimization

## Строки
### Хеширование строк
### Z-функция
### Префикс-функция (KMP)
### Алгоритм Манакера (палиндромы)
### Суффиксный массив
### Алгоритм Ахо-Корасик
### Бор (Trie)
### Суффиксное дерево (Suffix Tree)
### Суффиксный автомат (Suffix Automaton)
### Полиномиальное хеширование (несколько баз)

## Математика
### Решето Эратосфена
### НОД и НОК (алгоритм Евклида)
### Расширенный алгоритм Евклида
### Модульная арифметика
### Обратные элементы по модулю
### Китайская теорема об остатках
### Комбинаторика (биномиальные коэффициенты, перестановки, субфакториал)
### Теория чисел
### Линейная алгебра (матрицы)
### Быстрое возведение в степень
### Функция Эйлера
### Дискретное преобразование Фурье (FFT/NTT)
### Мобиус инверсия
### Теорема Лукаса
### Алгоритм Гаусса (системы линейных уравнений)
### Матричное возведение в степень

## Алгоритмы и техники
### Жадные алгоритмы
### Divide and Conquer
### Перебор с отсечениями (backtracking)
### Meet in the Middle
### Координатное сжатие

## Геометрия
### Базовые операции с точками и векторами
### Скалярное и векторное произведение
### Проверка пересечения отрезков
### Выпуклая оболочка (Convex Hull)
### Площадь многоугольника
### Поворот и масштабирование точек
### Ближайшая пара точек
### Пересечение прямых и отрезков
### Точка в многоугольнике
### Триангуляция Делоне

## Другое
### Битовые операции и маски
### Тернарный поиск
### STL контейнеры и алгоритмы (C++)
### Стружка ускоряющая IO
### Разреженные графы и матрицы
### Теория игр (Nim, Grundy numbers)
### Рандомизированные алгоритмы
### Mo's Algorithm (алгоритм Мо)
### Parallel Binary Search
### Alien's Trick (Lagrange Optimization)
### Offline запросы и Small to Large